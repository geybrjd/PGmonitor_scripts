Оценка времени ожидания

/*
	Для оценки времени ожадания понадобится поле pg_lock.waitstart. Если процесс не находится
в ожидании, то значение этого поля будет отсутствовать. Если процесс не смог взять блокировку,
он переходит в ожидание, и это поле показывает время перехода в ожидание. Здесь есть неявная
связь с другим полем этого же представления: на ожидание блокировки показывает не только waitstart,
но и флаг granted. Однако они не полностью согласованы, и waitstart может в течение короткого
периода содержать NULL, когда поле granted уже устновлено false.
*/


/*
	В этом случае получается общее время ожидания, и чем оно больше, тем хуже ситуация, особенно
в системах с большой конкурентностью. Вариант подходит для общей оценки того, сколько
времени СУБД тратит на ожидание.
*/

select a.pid, a.state, l.granted,
a.wait_event ||'.'||a.wait_event_type as wait,
clock_timestamp() - l.waitstart as wait_age
from pg_stat_activity a , pg_locks l
where a.pid = l.pid
and not l.granted;
  pid   | state  | granted |        wait        |    wait_age
--------+--------+---------+--------------------+-----------------
 863129 | active | f       | transactionid.Lock | 00:00:03.781421

/*
	В этом случае получится картина только по одному процессу, который ждет дольше всех
остальных. Вариант подходит для оперативного мониторинга, чтобы понимать, что в конкретный момент есть (или был) конкретный процесс, который находился в ожидании конкретный
интервал времени.
*/

with q as (
select clock_timestamp() - l.waitstart as wait_age
from pg_stat_activity a, pg_locks l
where a.pid=l.pid and not l.granted
) select count(*),
coalesce(max(wait_age), '0'::interval) as max,
coalesce(sum(wait_age), '0'::interval) as sum
from q;

count|     max       |   	sum
-----+---------------+---------------
2	 |00:01:16.809039|00:01:53.051283

/* 
	Здесь мы наблюдаем что во время опроса, было 2 процесса 
самый долгий жадл 1м 16с
суммарно клиенты прождали 1м 53с
*/
